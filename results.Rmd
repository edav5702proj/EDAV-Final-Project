# Results

<script src="https://d3js.org/d3.v7.min.js"></script>

<!-- Zoom in -->
<div id="myModal" class="modal">

  <!-- The Close Button -->
  <span class="close">&times;</span>

  <!-- Modal Content (The Image) -->
  <img class="modal-content" id="img01">

  <!-- Modal Caption (Image Text) -->
  <div id="caption"></div>
</div>

## Assumption

```{r, out.extra='id:"avg_abnormal"'}
process_name <- function(csv) {
    return(gsub("  ", "", gsub(".csv", "", gsub("_", " ", csv))))
}

get_attraction_name <- function() {
    return(lapply(list.files("Data/data/Magic Kingdom/xysong_python"), process_name)) # nolint
}
# get_attraction_name() #nolint


read_all <- function() {
    library(hash)
    # filenames <- list.files("Data/data/Magic Kingdom/xysong_python") # nolint
    filenames <- list.files("Data/data/cleaned/") # nolint
    dict <- hash()
    for (csv in filenames) {
        # dict[[process_name(csv)]] <- read.csv(sprintf("Data/data/Magic Kingdom/xysong_python/%s", csv)) # nolint
        dict[[process_name(csv)]] <- read.csv(sprintf("Data/data/cleaned/%s", csv)) # nolint
    }
    return(dict)
}
```
As introduced in the data cleaning section, our exploratory analysis is heavily based on 
the _waiting\_time_ statistics of attractions in the Walt Disneyland collected from thrid-party 
organization. Therefore, it is extremely crucial 
to examine the validity and reliability of the _assumptions_ that our analysis will rely on and 
think about any _inductive biases_ that we implicitly impose in the analysis. Specifically, there are 
two important aspects that we want to research on:

- Assumption 1: the dataset is valid and reliable (i.e. no internal conflicts)
- Assumption 2: waiting time statistic is a representative metric for analysis


### Assumption 1
Unlike most other groups whose datasets come from official sources including government websites 
and database where verifications are conducted, the dataset we used is collected from a __thrid 
party organization__ [Touringplans.com]([https://touringplans.com/walt-disney-world/crowd-calendar#DataSets]).
Therefore, validation of dataset is necessary and important. We performed our validation by identifying 
internal conflicts of datasets and compare our preliminary analysis with reports from the official (i.e. Disneyland).

The first simple task we tried to validiate our dataset is to predict top seven attractions according to 
their popularity. In our dataset, we computed the _average waiting time_ for each attraction (denoted by _AWT_ in the plot) and 
made usage of the _average\_wait\_every\_hundred_ statistic (i.e. denoted by _AWT\_100_ in the plot) to do the prediction. 
Note that _AWT\_100_ represents the average waiting time for every hundred people. Therefore, attractions that are 
popular should be those with high _AWT_ but low _AWT\_100_. 
```{r}
library(ggplot2)
library(ggeasy)
library(dplyr)
library(lubridate)
library(tidyverse)
# Setup scripts
all_dsets <- read_all()
# mean(all_dsets[["dumbo"]]$Waiting.Time)
```
```{r}
# Read avg_wait_100 files
avg_wait_100 <- read.csv("Data/data/name_avg_wait.csv")
get_avg_df <- function(df) {
    return(mean(df$Waiting.Time))
}
# 18 out of 25 rows have correponding no-NAs values
avg_wait <- rep(0, 18)
for (i in 1:18) {
    avg_wait[[i]] <- mean(all_dsets[[avg_wait_100$name[[i]]]]$Waiting.Time)
}
avg_wait_100$avg <- avg_wait
avg_wait_100$popular <- rep("Other Attractions", 18)
# Manually insert popular
for (i in c(1, 2, 5, 6, 7, 8, 17)) {
    avg_wait_100$popular[[i]] <- "Top 7 Popular Attractions"
}
# avg_wait_100$popular
# avg_wait_100
# Plot
g0 <- ggplot(avg_wait_100, aes(avg_wait_time, avg, color = popular)) +
    geom_point(alpha = 0.4, size = 4) +
    labs(x = "AWT_100 (min)", y = "AWT (min)") + # nolint

    ggtitle("AWT vs. AWT_100") +
    ggeasy::easy_center_title()
g0
```

According to this reasoning, we identified that the top 7 most popular attractions from the 
scatter plot above: _Seven Dwarfs Mine Train_, _Space Mountain_, _Jungle Cruise_, _Splash Mountain_
, _Big Thunder Mountain Railroad_, _Pirates of Caribbean_, and _Haunted Mansions_. Based on the report of 
most popular attractions by [magicguides.com](https://magicguides.com/best-magic-kingdom-rides/) and the 
introduction from [Disneyland Officials](https://disneyworld.disney.go.com/destinations/magic-kingdom/?ef_id=CjwKCAiAheacBhB8EiwAItVO2w0FdC8qLzR3mnfUO_KKMy3L1hkZoT3LEHDEm9hiGW9Keu9XNjT1JhoC0t0QAvD_BwE:G:s&s_kwcid=AL!5060!3!590827088345!e!!g!!magic%20kingdom%20theme%20park&CMP=KNC-FY23_WDW_TRA_DXF_W365_TKT_TCKC_Tickets_EVRGRN_MKParks-Exact|G|5231213.RR.AM.01.01|M5JMF0M|BR|590827088345&keyword_id=kwd-1416849944|dc|magic%20kingdom%20theme%20park|590827088345|e|5060:3|&gclid=CjwKCAiAheacBhB8EiwAItVO2w0FdC8qLzR3mnfUO_KKMy3L1hkZoT3LEHDEm9hiGW9Keu9XNjT1JhoC0t0QAvD_BwE) 
the most popular 7 attractions are: _Big Thunder Mountain Railroad_, _Jungle Cruise_
, _Splash Mountain_, _Peter Pan's Flight_, _Haunted Mansions_, _Pirates of Caribbean_, and _Seven Dwarfs Mine Train_. 
Our prediction results matched with most of their analysis (6/7), and we can improve our confidence about the 
reliability of the source data from this small prediction task. In addition, there is no internal conflict in our dataset 
because they are all time series data for different attractions.

### Assumption 2

By calculating and plotting the waiting time for each attraction, 
we identified that _average waiting time_ itself is not a good indicator for 
popularity of the attraction. Note that we observe that the _average waiting time_ is not always higher for 
popular attractions identified in previous section. Thus, we should not solely leverage on that when analyzing the popularity of attractions. However, 
with the power of time series data, it is powerful when analyzing trend and designing visiting plans.

```{r}
num_dsets <- length(all_dsets)
names <- get_attraction_name()
avg_wait <- rep(0, num_dsets)
for (i in 1:num_dsets) {
    avg_wait[[i]] <- mean(all_dsets[[names[[i]]]]$Waiting.Time)
}
# avg_wait
df <- data.frame(
    name = c(unlist(names)),
    avg_wait = c(unlist(avg_wait)),
    popular = c(unlist(rep("Other Attractions", 25)))
)
# names
for (i in c(1, 4, 11, 13, 19, 21, 22)) {
    df$popular[[i]] <- "Top 7 Popular Attractions"
}
# names
g1 <- df %>% ggplot(aes(x = fct_reorder(name, avg_wait, .desc = TRUE), y = avg_wait, fill = popular)) + # nolint
    geom_bar(stat = "identity", alpha = 0.8) +
    ggtitle("Average Waiting Time for Each Attraction") +
    xlab("Attractions") +
    ylab("AWT") +
    # scale_color_manual()+
    ggtitle("AWT vs. Attraction") +
    ggeasy::easy_center_title() +
    scale_x_discrete(guide = guide_axis(angle = 45)) +
    theme(panel.grid.major.x = element_blank())
g1
```

## General Pattern Analysis - Macro-Level
With confidence of dataset validity, we first analyze the pattern of waiting time of each attraction 
spanning from _2015-01-01_ to _2022-01-01_, by which we can identify the peak season of Walt Disneyland. Note that for this section, 
we are doing macro-scale analysis, implying we will focus on the _average waiting time_ for each month for each attraction. 

### Secular Trends

To identify secular trend, we computed the _average waiting time_ for each month for all attractions and then made the following time series plot. 
Here is the main observations:

- ***Obs #1:*** From _2015_ to _2019_, there is a general trend of increasing waiting time.\
***Exp:*** as Disneyland became more famous, there are more tourists but the attractions remain unchanged, which result in an increasing of waiting time.
- ***Obs #2:*** From about _2019_ to _2020_, there is a huge decreasing in terms of waiting time.\
***Exp:*** this corresponds to the outbreak of COVID-19 in the United States, which result in the temporary close of Disneyland and the huge decreasing of number of tourists even after reopening.
- ***Obs #3:*** Starting from _2020_, there is a general trend of increasing waiting time\
***Exp:*** this corresponds to the fact that people are back to normal life from COVID disruption.
- ***Obs #4:*** There is an obvious abnormality in the plot (_2020-04-01_ to _2020-10-01_), where the waiting times are all zeros, which correpond to the 
closure of Disneyland. (Note that there is a design choice for plotting; see Data Cleaning section for details)

**Note**: According to Disneyland's Officials, Disneyland was closed during COVID-19 outbreaks
```{r}
# source("Utility/utils.R")

all_dsets <- read_all()
dumbo <- all_dsets[["dumbo"]]
# class(dumbo)
# Elementary statistics
# head(dumbo)
# Get all datasets
df_all <- bind_rows(lapply(get_attraction_name(), function(i) all_dsets[[i]]))
# nrow(df_all) #nolint

# Example
# head(dsets) #nolint
group_by <- function(df) {
    # Process dataframe
    dsets <- df %>%
        dplyr::mutate(Datetime = as.Date(Datetime, "%Y-%m-%d %H:%M:%S")) %>%
        dplyr::mutate(month = lubridate::floor_date(Datetime, "month")) %>%
        dplyr::group_by(month) %>%
        dplyr::summarise(avg = sum(Waiting.Time) / n())
    return(dsets)
}

plot_time_series <- function(dsets, name) { # Plot
    g <- ggplot(dsets, aes(month, avg), type = "l") +
        geom_line(color = "black") +
        # geom_line(color = "#F3CC64") +
        geom_point(color = "deeppink", alpha = 0.4) +
        geom_smooth(method = "loess", span = .5, se = FALSE) +
        scale_x_date(date_labels = "%b %Y", date_breaks = "6 months", guide = guide_axis(angle = 45)) + # nolint
        xlab("Month") +
        ylab("Average Waiting Time (minutes)") +
        ggtitle(sprintf("%s: Average Waiting Time (By Month)", name)) +
        ggeasy::easy_center_title()
    return(g)
}
identify_abnormal <- function(g, start, end, text_y) {
    g <- g + annotate("rect", xmin = start, xmax = end, ymin = -Inf, ymax = Inf, fill = "lightblue", alpha = 0.3) # nolint
    # Append text
    g <- g + annotate("text", x = end + 10, y = text_y * (4 / 5), label = "COVID \nOUTBREAK", color = "#393E8F", hjust = 0) # nolint
    return(g)
}

plot_in_one_shot <- function(df, name) {
    grouped_dsets <- group_by(df)
    g <- plot_time_series(grouped_dsets, name)
    start <- as.Date("2020-01-01")
    end <- as.Date("2020-12-01")
    g <- identify_abnormal(g, start, end, max(grouped_dsets$avg))
    return(g)
}
# nrow(df_all) #nolint
g2 <- plot_in_one_shot(df_all, "All Attractions")
g2
```

Below are the time series plot for the average waiting time changing pattern for each attraction in Disneyland. **Click on the plots to zoom in**. 
Through this juxtaposition, we can easily observed that the four trends and abnormalites that 
we identified eariler is ***universal*** across all attractions, and we do not subject to _Simpson's Paradox_.

<!-- :::{#abnormal_plot} -->
```{r, fig.show="hold", out.width="20%", out.extra='class="abnormal"'}
all_plot <- list()
names <- get_attraction_name()
# length(names)
# names
for (i in 1:25) {
    name <- names[[i]]
    all_plot[[i]] <- plot_in_one_shot(all_dsets[[name]], name)
}
for (g in all_plot) {
    print(g)
}
```
<!-- ::: -->


### Identify cyclical patterns

Time series data commonly share some underlying cyclical patterns. We utilized faceting techniques to 
isolate average waiting time for each year and identify the following trends and patterns: (Explanations are based on 
news, activities, and reports published by Disneyland Officials)

- ***Obs #1:*** We managed to identify cyclical patterns by isolating _AWT_ for each year.
- ***Obs #2:*** In general, there are two peaks of _AWT_ for attractions in Disneyland: _April - Late May_ (spring peak) and _December - January_ (winter peak). \
***Exp:*** Spring _AWT_ peak corresponds to the fact that there are tons of activities held in that period, whereas winter peak is the direct result 
of Christmas Holiday (Note that Florida is a good place to stay for many people during winter).
- ***Obs #3:*** In _2020_, we observed a completely different trend due to the temporary closure of the park. 
- ***Obs #4:*** In _2021_, the general _AWT_ decreases but the peaks are still around spring and winter. \
***Exp:***  the decreasing waiting time (compared to _2015_ to _2019_) accounts for the influence of COVID-19 to people's life, while the consistency of peak seasons 
confirmed the validity of previously-observed trends.

:::{#facet}
```{r, fig.show="hold", out.width="100%"}
dumbo <- all_dsets[["dumbo"]]
# dumbo
# head(dumbo)
# sum(dumbo$Waiting.Time) / nrow(dumbo)
group_by_date <- function(df) {
    # Process dataframe
    dsets <- df %>%
        dplyr::mutate(Datetime = as.Date(Datetime, "%Y-%m-%d %H:%M:%S")) %>%
        dplyr::group_by(Datetime) %>%
        dplyr::summarise(avg = sum(Waiting.Time) / n()) %>%
        dplyr::mutate(yr = year(Datetime))
    return(dsets)
}
# dset <- group_by_date(dumbo)
# head(dset)
plot_faceting_in_one_shot <- function(df, name) {
    dset <- group_by_date(df)
    g <- ggplot(dset, aes(as.Date(format(Datetime, format = "%m-%d"), "%m-%d"), avg)) + # nolint
        # geom_line(color = "grey30") +
        geom_point(size = 0.05, color = "deeppink", alpha = 0.4) +
        scale_x_date(date_labels = "%b", date_breaks = "3 months", guide = guide_axis(angle = 45)) + # nolint
        facet_grid(. ~ yr, scale = "free_y") +
        xlab("Month") +
        ylab("Average Waiting Time (minutes)") +
        ggtitle(sprintf("%s: Average Waiting Time (By Month)", name)) +
        ggeasy::easy_center_title() +
        geom_smooth(se = FALSE, color = "#393E8F")
    return(g)
}
# dumbo <- all_dsets[["dumbo"]]
plot_faceting_in_one_shot(df_all, "All Attractions")
```
:::

Similarly, we can plot the _AWT_ for each attraction as what we did for the previous section to further confirm the global trends. 
***Click on the plots below to zoom in.*** Here are the main takeaway from these plots:

- ***Obs #1:*** _Most of the attractions_ share the similar patterns as identified before.
- ***Obs #2:*** For attractions whose data are not sufficiently large (refer to Data Cleaning section for details), spring and winter peaks are observed as well.
- ***Obs #3:*** Combined previous two observations, we can safely conclude that we do not suffer from _Simpson's Paradox_ and the trend is valid.
- ***Obs #4:*** From this juxtapositin, we can easily discover features about each attraction. For example, 
we can quickly guess that _Hall of Presidents_ was closed in 2017 (annoucement from Disneyland Officials confirmed our conjecture).

```{r, fig.show="hold", out.width="20%", out.extra='class="abnormal"'}
all_plot <- list()
names <- get_attraction_name()
# length(names)
# names
for (i in 1:25) {
    name <- names[[i]]
    all_plot[[i]] <- plot_faceting_in_one_shot(all_dsets[[name]], name)
}
for (g in all_plot) {
    print(g)
}
```
```{r}
# Check duration
df <- read.csv("Data/data/name_duration.csv")
df
avg_wait <- rep(0, 18)
for (i in 1:18) {
    avg_wait[[i]] <- mean(all_dsets[[df$name[[i]]]]$Waiting.Time)
}
df$avg <- avg_wait
write.csv(df, "Data/data/name_duration_avg.csv", row.names = FALSE)
# Check writing csv
df <- read.csv("Data/data/name_duration_avg.csv")
```
<script src="zoom.js"></script>

### Section Conclusion

A main takeaway of this macro-level analysis for tourists is that spring and winter are two peak seasons that the _AWT_ is higher than 
that of other time; this trend is exhibited both before and after COVID-19, and will be consistent in the future. Therefore, one natural 
suggestion is to visit the park in summer or fall.

## General Pattern Analysis - Micro-Level

Based on our exploratory analysis in the previous section, _AWT_ of all attractions is a good representation of _AWT_ of 
each attraction. This crucial observation allowed us to conduct micro-level analysis on the cyclical 
pattern that we identified earlier. 

### AWT vs. Days

Specifically, we focused on the _AWT_ of all attractions for each day in a year. Although we have already identified that there 
are two peaks (spring and winter) of _AWT_, we hope that this micro-level analysis can bring more intuitions about the underlying reasons.

```{r}
filenames <- list.files("Data/data/cleaned")
library(hash)
dict <- hash()
for (csv in filenames) {
    dict[[csv]] <- read.csv(sprintf("Data/data/cleaned/%s", csv))
}
# dict[["dumbo.csv"]]
```

```{r}
avg <- list()
for (csv in filenames) {
    date <- substr(dict[[csv]]$Datetime, 1, 10)
    ymd <- as.Date(date, format = "%Y-%m-%d")
    weekday <- weekdays(ymd)
    yr <- substr(dict[[csv]]$Datetime, 1, 4)
    yr <- format(as.Date(yr, format = "%Y"), "%Y")
    md <- substr(dict[[csv]]$Datetime, 6, 10)
    md <- format(as.Date(md, format = "%m-%d"), "%m-%d")
    dict[[csv]] <- cbind(dict[[csv]], ymd)
    dict[[csv]] <- cbind(dict[[csv]], weekday)
    dict[[csv]] <- cbind(dict[[csv]], yr)
    dict[[csv]] <- cbind(dict[[csv]], md)
}
```

```{r}
first <- 1
for (csv in filenames) {
    if (first == 1) {
        df_ymd <- dict[[csv]] %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_md <- dict[[csv]] %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_weekday <- dict[[csv]] %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))

        df_ymd_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_md_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_weekday_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))

        df_ymd_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_md_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_weekday_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))
        first <- 2
    } else {
        df_nymd <- dict[[csv]] %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nmd <- dict[[csv]] %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nweekday <- dict[[csv]] %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))

        df_nymd_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nmd_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nweekday_before <- dict[[csv]] %>%
            filter(ymd < "2020-01-01") %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))

        df_nymd_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(ymd) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nmd_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(md) %>%
            summarise(avg_wait = mean(Waiting.Time))
        df_nweekday_after <- dict[[csv]] %>%
            filter(ymd > "2020-12-01") %>%
            dplyr::group_by(weekday) %>%
            summarise(avg_wait = mean(Waiting.Time))

        df_ymd <- merge(df_ymd, df_nymd, by = "ymd", all = TRUE)
        df_md <- merge(df_md, df_nmd, by = "md", all = TRUE)
        df_weekday <- merge(df_weekday, df_nweekday, by = "weekday", all = TRUE)

        df_ymd_before <- merge(df_ymd_before, df_nymd_before, by = "ymd", all = TRUE)
        df_md_before <- merge(df_md_before, df_nmd_before, by = "md", all = TRUE)
        df_weekday_before <- merge(df_weekday_before, df_nweekday_before, by = "weekday", all = TRUE)

        df_ymd_after <- merge(df_ymd_after, df_nymd_after, by = "ymd", all = TRUE)
        df_md_after <- merge(df_md_after, df_nmd_after, by = "md", all = TRUE)
        df_weekday_after <- merge(df_weekday_after, df_nweekday_after, by = "weekday", all = TRUE)
    }
}
```

```{r}
average_wait <- rowMeans(df_md[2:26], na.rm = TRUE)
df_mdwait <- cbind(df_md[1], average_wait)
df_mdwait <- na.omit(df_mdwait)
df_mdwait$md <- as.Date(df_mdwait$md, format = "%m-%d")
```

```{r}
ggplot(df_mdwait, aes(x = md, y = average_wait)) +
    geom_line() +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %d") +
    xlab("Day") +
    ylab("AWT (min)") +
    ggtitle("AWT of All Attractions for Every Day") +
    ggeasy::easy_center_title()
```

From the graph above, we have the following observations:

- ***Obs #1:*** We clearly identified that there are two periods where the _AWT_ decrease significantly: 
_Late August to Early September_ and _Beginning of January_ \
***Exp:*** One possible explanation is that by the start of the Winter semester, 
students, who occupy a large proportion of visitors, are going back to school, 
resulting in fewer visitors to Disneyland.
- ***Obs #2:*** In this micro-level analysis, we manage to identify **the thrid** peak, which is around _Late June to Early August_. \
***Exp:*** This corresponds to the fact that most schools (ranging from Universities to Kindergarten) are in vacations.
- ***Obs #3:*** confirmed the effectiveness and necessity of this micro-level analysis.

<!-- exhibits an increasing pattern until _April_, when it decreases by almost 25%. This is probably becauase the Disneyland was closed on April, 2022. The number stays at the same level for about four months before dropping dramatically in August, which can be explained by the start of the Fall semester. From September to January, the waiting time generally increases, except for the first half of October and the second half of November, when it suddenly increases and then goes back to the original level. These two peaks correspond to the Fall break and Thanksgiving break, when many students are freed from school and visit the Magic Kingdom. -->

<!-- We believe that the waiting time is related to students' schedules. When students need to go back to school, the waiting time is short. When they have breaks, the waiting time is longer. The sudden drops in January and August are two significant pieces of evidence that support our argument. -->
Recall in previous section, we discovered that there is an abnormal pattern in _2020_ due to COVID disruption. Therefore, a plot like above may not be 
sufficient to capture this variation. Therefore, we manually filtered the data and compare the patterns of _AWT_ before and after COVID outbreak.


```{r}
average_wait_before <- rowMeans(df_md_before[2:26], na.rm = TRUE)
average_wait_after <- rowMeans(df_md_after[2:26], na.rm = TRUE)
df_mdwait_before <- cbind(df_md[1], average_wait_before)
df_mdwait_covid <- cbind(df_mdwait_before[-366, ], average_wait_after)
df_mdwait_covid <- na.omit(df_mdwait_covid)
df_mdwait_covid$md <- as.Date(df_mdwait_covid$md, format = "%m-%d")
```

```{r}
ggplot(df_mdwait_covid, aes(x = md)) +
    # geom_point()+
    geom_line(aes(y = average_wait_before, colour = "average_wait_before")) +
    geom_line(aes(y = average_wait_after, colour = "average_wait_after")) +
    scale_colour_manual("",
        breaks = c("average_wait_before", "average_wait_after"),
        values = c("#0047DF", "#B12228"),
        labels = c("Before COVID", "After COVID")
    ) +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %d") +
    xlab("Day") +
    ylab("AWT (min)") +
    ggtitle("Average waiting time for every day") +
    ggeasy::easy_center_title()
```

Specifically, we manually classify the periods before _2020-01-01_ as _Before COVID_ period and time after _2021-01-01_ as 
the _After COVID_ periods. The reasoning behind this is that the COVID outbreaks occurred at the beginning of _2020_ and it is under control at the end of _2020_ according to the report from [CDC](https://www.cdc.gov/). 
The second reason is inherited from the internal nature of our dataset, where we have tons of missing data between 
_2020-04-01_ and _2020-10-01_ due to Disneyland's closure; thus, it is reasonable to remove the data from whole year and use this year as a threshold. 
Based on our plots, here are the main observations:

- ***Obs #1:*** There is a trend of decreasing _AWT_ for nearly all time periods in a year after COVID outbreak.\
***Exp:*** the concerns of public safety prevented many people from going out and travelling.
- ***Obs #2:*** There exists outlier of the trend in ***Obs #1***: in Christmas, the _AWT_ is higher than before.\
***Exp:*** Recall our threshold for _After COVID_ period is _2021-01-01_ to _2022-01-01_, so in December 2022, there is already 1.5 years since 
COVID's outbreak so people's life is getting back to normal.
- ***Obs #3:*** After COVID-19 shutdown, in _January_, there is a significant drop in _AWT_ compared to patterns before COVID-19. \
***Exp:*** Again, public safety concerns and schools reopening led to less tourists.

### AWT vs. Weekday

In the previous section, we move from a macro-level analysis to a micro-level analysis by focusing on each day 
in a year. Similarly, we can do one step further to examine the _AWT_ for each day in a week in order to identify 
the patterns within a week. 


```{r}
weekday_wait <- rowMeans(df_weekday[2:26], na.rm = TRUE)
df_weekwait <- cbind(df_weekday[1], weekday_wait)
df_weekwait$weekday <- factor(df_weekwait$weekday, levels = c(
    "Sunday", "Monday",
    "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
))
df_weekwait <- df_weekwait[order(df_weekwait$weekday), ]
```

```{r}
ggplot(df_weekwait, aes(x = weekday, y = weekday_wait)) +
    geom_bar(stat = "identity", fill = "skyblue") +
    geom_text(aes(label = round(weekday_wait, 2)), vjust = -0.5, colour = "black") +
    ylab("AWT (min)") +
    xlab("Weekday") +
    ggtitle("AWT for every weekday") +
    ggeasy::easy_center_title()
```

According to the plot above, here are the main observations:

- ***Obs #1:*** We do expect _Saturday_ has a relatively high waiting time before we start the project. 

- ***Obs #2:*** On the other hand, surprisingly, _Sunday_ has the least _AWT_, while _AWT_ of _Monday_ and _Wednesday_ are above average.

- ***Obs #3:*** However, even though there are difference among each day in a week, the difference is not huge. The maximum difference is only about 5 minutes.

Similarly, we can make plots to examine the patterns before and after COVID-19, and we sticked with the 
thresholds that we used in previous sections.

```{r}
weekday_wait_before <- rowMeans(df_weekday_before[2:26], na.rm = TRUE)
df_weekwait_before <- cbind(df_weekday_before[1], weekday_wait_before)
df_weekwait_before <- cbind(df_weekwait_before, c("before", "before", "before", "before", "before", "before", "before"))
colnames(df_weekwait_before) <- c("weekday", "weekday_wait", "covid")

weekday_wait_after <- rowMeans(df_weekday_after[2:26], na.rm = TRUE)
df_weekwait_after <- cbind(df_weekday_after[1], weekday_wait_after)
df_weekwait_after <- cbind(df_weekwait_after, c("after", "after", "after", "after", "after", "after", "after"))
colnames(df_weekwait_after) <- c("weekday", "weekday_wait", "covid")

df_weekwait_covid <- rbind(df_weekwait_before, df_weekwait_after)
df_weekwait_covid$weekday <- factor(df_weekwait_covid$weekday, levels = c(
    "Sunday", "Monday",
    "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
))
df_weekwait_covid <- df_weekwait_covid[order(df_weekwait_covid$weekday), ]
df_weekwait_covid$covid <- factor(df_weekwait_covid$covid, levels = c("before", "after"))
```

```{r}
ggplot(df_weekwait_covid, aes(fill = covid, x = weekday, y = weekday_wait)) +
    geom_bar(stat = "identity", position = position_dodge(width = 0.9)) +
    geom_text(position = position_dodge(width = 0.9), aes(label = round(weekday_wait, 2), hjust = 0.5, vjust = -0.5), colour = "black", size = 3.2) +
    ylab("AWT (min)") +
    ggtitle("AWT for every weekday before and after covid") +
    ggeasy::easy_center_title()
```

The graph above showed that the _AWT_ for each weekday before COVID-19 is lower than that after COVID-19. 

- ***Obs #1:*** By calculation, _AWT_ dropped from 31.45 minutes to 26.26 minutes. 
This indicates that on average, for every 2.5 hours, the tourists can enjoy one more attraction after the Covid than before.
<!-- The tourists spend less time on waiting and enjoy more facilities after the Covid. -->
- ***Obs #2:*** Similarly, the difference is still not huge among all weekdays, implying that weekday is not a huge factor that impacts people's traveling plan to Disneyland.

## Attraction-Level _AWT_ Analysis

### _AWT_ vs. Attraction
```{r}
library(ggplot2)
library(plyr)
library(dplyr)
library(tidyverse)

# install.packages("hash")
library(hash)
# install.packages("reticulate")
library(reticulate)
library(ggridges)
library(forcats)
```

```{r}
process_name <- function(csv) {
    return(gsub("  ", "", gsub(".csv", "", gsub("_", " ", csv))))
}

get_attraction_name <- function() {
    return(lapply(list.files("Data/data/cleaned"), process_name))
}

filenames <- list.files("Data/data/cleaned")
# filenames
dict <- hash()
for (csv in filenames) {
    dict[[process_name(csv)]] <- read.csv(sprintf("Data/data/cleaned/%s", csv))
}
```

```{r}
avg <- list()
for (csv in filenames) {
    avg <- append(avg, mean(dict[[process_name(csv)]]$Waiting.Time))
}
```

```{r}
avg_time <- data.frame(unlist(get_attraction_name()), unlist(avg))
names(avg_time) <- c("Ride", "avgtime")
```

```{r}
g <- ggplot(avg_time, aes(x = avgtime, y = fct_reorder(Ride, avgtime))) +
    geom_point(color = "#B12228") +
    labs(
        title = "Average Waiting Time for Each Attraction",
        x = "Average Waiting Time (in minutes)",
        y = "Attraction"
    )
# ggeasy::easy_center_title()
```

<!-- The above Cleveland dot plot shows the average wait time for each attraction, and they are ranked in descending order with the longest time at the top. The Seven Dwarfs Mine Train attraction has the longest average waiting time of around 79.2 minutes. The second highest is the Space Mountain attraction, and it has an average wait time of 58.3 minutes. The third highest has a very close average wait time as the second one, and it is the Peter Pan's Flight attraction with a wait time of 58.0 minutes. The fourth is the Splash Mountain with an average wait time of 45.1 minutes, and the fifth is the Jungle Cruise with an average wait time of 44.2 minutes.       -->
```{r}
sort_df <- avg_time[order(-avg_time$avgtime), ]
top_five <- list()
df_comb <- NA
for (i in head(sort_df, 5)$Ride) {
    dict[[i]]["ride"] <- i
    df_comb <- rbind(df_comb, dict[[i]])
}
df_comb <- na.omit(df_comb)
```

```{r}
# reorder(ride, -Waiting.Time, median)
# ggplot(df_comb, aes(x = Waiting.Time, y = reorder(ride, Waiting.Time, median))) +
#     geom_boxplot() +
#     labs(
#         title = "Top 5 AWT",
#         x = "AWT",
#         y = "Attraction"
#     ) +
#     ggeasy::easy_center_title()
```

```{r}
ggplot(df_comb, aes(x = Waiting.Time, y = reorder(ride, Waiting.Time, median))) +
    geom_density_ridges(fill = "#EFBEB7", alpha = .5, bandwidth = 7, scale = 1.4) +
    ggtitle("Top 5 Attraction AWT") +
    ylab("Attraction") +
    xlab("AWT") +
    xlim(c(-30, 250)) +
    ggeasy::easy_center_title()
```

The above is a Ridgeline plot that shows the wait time distribution of the top five attractions with the longest wait time, and they are ranked by their medians in descending order with the longest time at the top. 

- ***Obs #1:*** The ranking is almost the same as in the average wait time chart, except Space Mountain and Peter Pan's Flight switched order

- ***Obs #2:*** All of data have unimodel distribution except Splash Mountain

- ***Obs #3:*** The modes are around 50 minutes

- ***Obs #4:*** There are some waiting time less than 0 minute \
***Exp:*** There should be a clear cut at 0 minute. However, to make the graph smooth, we have some data showed less than zero.

### _AWT_ vs. Attraction: time of a day

```{r}
# name_list <- list()
# for (csv in filenames) {
#   temp <- process_name(csv)
#   name_list <- append(name_list, temp)
#   dict[[temp]]$Datetime <- as.POSIXlt(dict[[temp]]$Datetime)
# }
```

```{r}
# m_avg <- list()
# a_avg <- list()
# e_avg <- list()
# for (n in name_list) {
#   m_avg <- append(m_avg, mean(dict[[n]][dict[[n]]$Datetime$hour < 12, 'Waiting.Time']))
#   a_avg <- append(a_avg, mean(dict[[n]][((dict[[n]]$Datetime$hour >= 12) | (dict[[n]]$Datetime$hour < 18)), 'Waiting.Time']))
#   e_avg <- append(e_avg, mean(dict[[n]][dict[[n]]$Datetime$hour >= 18, 'Waiting.Time']))
# }

# m_avg_time = data.frame(unlist(name_list), unlist(m_avg))
# names(m_avg_time) = c("ride","avg")

# a_avg_time = data.frame(unlist(name_list), unlist(a_avg))
# names(a_avg_time) = c("ride","avg")


# e_avg_time = data.frame(unlist(name_list), unlist(e_avg))
# names(e_avg_time) = c("ride","avg")
```

```{r}
# m_avg_time['timeofday'] <- 'Morning'
# a_avg_time['timeofday'] <- 'Afternoon'
# e_avg_time['timeofday'] <- 'Evening'
# avg_comb <- NA
# avg_comb <- rbind(avg_comb, m_avg_time)
# avg_comb <- rbind(avg_comb, a_avg_time)
# avg_comb <- rbind(avg_comb, e_avg_time)
# avg_comb <- na.omit(avg_comb)
# # Save file
# avg_comb
# write.csv(avg_comb, "Data/data/avg_comb.csv")
df <- read.csv("Data/data/avg_comb.csv")
# df
```

```{r}
ggplot(df, aes(x = avg, y = fct_reorder2(ride, timeofday == "Afternoon", avg, .desc = FALSE), color = timeofday)) +
    geom_point() +
    labs(
        title = "AWT for Each Attraction",
        x = "AWT (min)",
        y = "Attraction"
    ) +
    guides(color = guide_legend(title = "Time of Day"))
```

The above Cleveland dot plot shows the average wait time of each attractive at different time of the day. The plot is sorted by the average afternoon wait time in descending order from top to bottom. 

- ***Obs #1:*** For 23 out of the 25 attractions, the average afternoon wait time is the longest. For the other 2 rides, the average morning wait time is the highest.

- ***Obs #2:*** For 17 out of 25 attractions, the average evening wait time is the shortest, and for the other 8 attractions, the average morning wait time is the shortest. 

- ***Obs #3:*** The attractions of the top 5 average afternoon wait time hold the same order as in the top 5 average wait time. 

### _AWT_ of Attractions vs. Land


```{r}
Adventureland <- c("enchanted tiki rm", "jungle cruise", "magic carpets", "pirates of caribbean")

Fantasyland <- c("7 dwarfs train", "dumbo", "it s a small world", "peter pan s flight", "winnie the pooh", "under the sea", "regal carrousel", "mad tea party", "barnstormer")

Frontierland <- c("big thunder mtn", "splash mountain", "country bears")

Tomorrowland <- c("buzz lightyear", "astro orbiter", "space mountain", "tom land speedway", "peoplemover", "carousel of progress")

Liberty_Square <- c("haunted mansion", "hall of presidents", "liberty sq riverboat")

section_name <- list("Adventureland", "Fantasyland", "Frontierland", "Tomorrowland", "Liberty Square")
```

```{r}
adventure <- bind_rows(lapply(Adventureland, function(i) dict[[i]]))
```

```{r}
fantasy <- bind_rows(lapply(Fantasyland, function(i) dict[[i]]))
```

```{r}
frontier <- bind_rows(lapply(Frontierland, function(i) dict[[i]]))
```

```{r}
tomorrow <- bind_rows(lapply(Tomorrowland, function(i) dict[[i]]))
```

```{r}
liberty <- bind_rows(lapply(Liberty_Square, function(i) dict[[i]]))
```

```{r}
avg_section <- c(mean(adventure$Waiting.Time), mean(fantasy$Waiting.Time), mean(frontier$Waiting.Time), mean(tomorrow$Waiting.Time), mean(liberty$Waiting.Time))
```

```{r}
section_avg <- data.frame(unlist(section_name), unlist(avg_section))
names(section_avg) <- c("section", "avg")
```

```{r}
ggplot(section_avg, aes(x = avg, y = fct_reorder(section, avg))) +
    geom_bar(stat = "identity", fill = "#393E8F") +
    labs(
        title = "AWT for Each Land",
        x = "AWT",
        y = "Land"
    ) +
    ggeasy::easy_center_title()
```

The above bar chart shows the average wait time by each themed land, and it is sorted by descending order from the top. 

- ***Obs #1:*** Frontierland has the longest average wait time followed by Tomorrowland. The rest have similar average wait time.

- ***Obs #2:*** The top 3 longest average wait time attractions - Seven Dwarfs Mine Train, Space Mountain, and Peter Pan's Flight - are not in the Frontierland. \
***Exp:*** This illustrates _Simpson's Paradox_.

```{r}
adventure$Datetime <- as.POSIXlt(adventure$Datetime)
fantasy$Datetime <- as.POSIXlt(fantasy$Datetime)
frontier$Datetime <- as.POSIXlt(frontier$Datetime)
tomorrow$Datetime <- as.POSIXlt(tomorrow$Datetime)
liberty$Datetime <- as.POSIXlt(liberty$Datetime)
```

```{r}
m_savg <- list()
a_savg <- list()
e_savg <- list()

section_name <- list("Adventureland", "Fantasyland", "Frontierland", "Tomorrowland", "Liberty Square")

m_savg <- append(m_savg, mean(adventure[adventure$Datetime$hour < 12, "Waiting.Time"]))
m_savg <- append(m_savg, mean(fantasy[fantasy$Datetime$hour < 12, "Waiting.Time"]))
m_savg <- append(m_savg, mean(frontier[frontier$Datetime$hour < 12, "Waiting.Time"]))
m_savg <- append(m_savg, mean(tomorrow[tomorrow$Datetime$hour < 12, "Waiting.Time"]))
m_savg <- append(m_savg, mean(liberty[liberty$Datetime$hour < 12, "Waiting.Time"]))

a_savg <- append(a_savg, mean(adventure[((adventure$Datetime$hour >= 12) | (adventure$Datetime$hour < 18)), "Waiting.Time"]))
a_savg <- append(a_savg, mean(fantasy[((fantasy$Datetime$hour >= 12) | (fantasy$Datetime$hour < 18)), "Waiting.Time"]))
a_savg <- append(a_savg, mean(frontier[((frontier$Datetime$hour >= 12) | (frontier$Datetime$hour < 18)), "Waiting.Time"]))
a_savg <- append(a_savg, mean(tomorrow[((tomorrow$Datetime$hour >= 12) | (tomorrow$Datetime$hour < 18)), "Waiting.Time"]))
a_savg <- append(a_savg, mean(liberty[((liberty$Datetime$hour >= 12) | (liberty$Datetime$hour < 18)), "Waiting.Time"]))

e_savg <- append(e_savg, mean(adventure[adventure$Datetime$hour >= 18, "Waiting.Time"]))
e_savg <- append(e_savg, mean(fantasy[fantasy$Datetime$hour >= 18, "Waiting.Time"]))
e_savg <- append(e_savg, mean(frontier[frontier$Datetime$hour >= 18, "Waiting.Time"]))
e_savg <- append(e_savg, mean(tomorrow[tomorrow$Datetime$hour >= 18, "Waiting.Time"]))
e_savg <- append(e_savg, mean(liberty[liberty$Datetime$hour >= 18, "Waiting.Time"]))

m_savgtime <- data.frame(unlist(as.character(section_name)), unlist(m_savg))
names(m_savgtime) <- c("section", "avg")
a_savgtime <- data.frame(unlist(as.character(section_name)), unlist(a_savg))
names(a_savgtime) <- c("section", "avg")
e_savgtime <- data.frame(unlist(as.character(section_name)), unlist(e_savg))
names(e_savgtime) <- c("section", "avg")
```

```{r}
m_savgtime["timeofday"] <- "Morning"
a_savgtime["timeofday"] <- "Afternoon"
e_savgtime["timeofday"] <- "Evening"
savg_comb <- NA
savg_comb <- rbind(savg_comb, m_savgtime)
savg_comb <- rbind(savg_comb, a_savgtime)
savg_comb <- rbind(savg_comb, e_savgtime)
savg_comb <- na.omit(savg_comb)
```

```{r}
ggplot(savg_comb, aes(x = avg, y = fct_reorder2(section, timeofday == "Afternoon", avg, .desc = FALSE), color = timeofday)) +
    geom_point(size = 3) +
    labs(
        title = "AWT for Each Land",
        x = "AWT (min)",
        y = "Land"
    ) +
    guides(color = guide_legend(title = "Time of Day")) +
    ggeasy::easy_center_title()
```

The above Cleveland dot plot shows the average wait time by each land at different time of the day. The plot is sorted by the average afternoon wait time in descending order from top to bottom. 

- ***Obs #1:*** The order of themed lands is the same as the one in the average wait time plot.

- ***Obs #2:*** For all themed lands, the average afternoon wait time is the longest. 

- ***Obs #3:*** The average evening time is the shortest for 4 of the 5 themed lands. Only one themed land has morning as the the shortest average wait time.   